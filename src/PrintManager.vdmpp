class PrintManager
instance variables
  clients:set of (Client) := {};
  employees:set of (Employee) := {};
  printers:set of Printer := {};
	queues: set of (Queue) := {};
	malfunctions: set of (Malfunction) := {};
	currentUser: [User] := nil; 
	private static printManager: PrintManager := new PrintManager();

operations

	-- User authentication

	private pure clientExists: seq of (char)  ==> bool
		clientExists(name) ==
			(
				for all client in set clients do
				(
					if client.getName() = name then
						return true;
				);
				return false;
			);
			
	private pure employeeExists: seq of (char)  ==> bool
		employeeExists(name) ==
			(
				for all employee in set employees do
				(
					if employee.getName() = name then
						return true;
				);
				return false;
			);
	

	public addClient: seq of (char) * seq of (char) * real ==> [Client]
		addClient(username,password,account) ==
			(
				dcl cli:Client := new Client(username,password,account);
				clients := clients union {cli};
				return narrow_(login(username, password), Client);
			)
			pre currentUser = nil and not clientExists(username)
			post RESULT.getName() = username and RESULT.getAccount() = account;
			
				
	public addEmployee: seq of (char) * seq of (char) * Employee`Role ==> [Employee]
		addEmployee(username, password, role) ==
			(
				dcl emp: Employee := new Employee(username, password, role);
			 	employees := employees union {emp};
			 	return narrow_(login(username, password), Employee);
			)
			pre currentUser = nil and not employeeExists(username)
			post RESULT.getName() = username and RESULT.getRole() = role;
			
			
	public login: seq of (char) * seq of (char) ==> [User]
		login(username, password) ==
		(
			dcl users: set of (User) := clients union employees;
			for all user in set users do
			(
				if user.isLoginCorrected(username, password) then
				(
					currentUser := user;
					return currentUser;
				);
			);
			return currentUser;
		)
		pre len password > 5 and len username > 3 and currentUser = nil;
		
	
	public logout: () ==> ()
		logout() ==
			currentUser := nil
		pre currentUser <> nil
		post currentUser = nil;
			
	-- Employee interaction
	
	
	public addQueue: Document`documentSize * Document`documentColor ==> Queue
		addQueue(size,color) ==
			(
				dcl queue:Queue := new Queue(size,color);
				queues := queues union {queue};
				return queue
			)
			pre currentUser <> nil and currentUser in set employees and (forall queue in set queues & queue.getSize() <> size and queue.getColor() <> color)
			post RESULT in set queues;
			
	
	public addPrinter: int * seq of (char) * set of Queue ==> Printer
		addPrinter(id,local,listofQueues) == 
			(
				dcl aux :Printer := new Printer(id,local,listofQueues);
				printers := printers union { aux };
				return aux
			)
			pre currentUser <> nil and currentUser in set employees and (forall printer in set printers & printer.getId() <> id)
			post RESULT in set printers;
			
	
	-- client interaction
	
	public addDocumentToQueue: Document ==> bool
		addDocumentToQueue(doc) ==
		(
			for all queue in set queues do 
			(
					if queue.getColor() = doc.getColor() and queue.getSize() = doc.getSize() then
					(
						queue.addDocument(doc);
						doc.setQueue(queue);
						return true;
					)
			);
			return false;
		)
		pre forall queue in set queues & doc not in set queue.getDocs() and currentUser <> nil and currentUser in set clients
		post doc.getQueue() <> nil;


	-- reporting
	
	public  reportPrintedDocs: ()  ==> ()
  	reportPrintedDocs() ==
    	is not yet specified
   	pre currentUser <> nil and currentUser in set employees;
   	

  public  reportClients : ()  ==> ?
  reportClients() ==
    is not yet specified
   pre currentUser <> nil and currentUser in set employees and currentUser.getRole() = <Admin>;
   

  public  reportEmployee : seq of (char)  ==> map Malfunction`malfunctionState to int
  reportEmployee(name) ==
  (
  	dcl allMalfs :map Malfunction`malfunctionState to int := {<InRepair>|-> 0,<Fixed> |-> 0};
    dcl employee :Employee := getEmployee(name);
    for all malfunction in set employee.getMalfunctions() do (
    	dcl pair :map Malfunction`malfunctionState to int := {malfunction.getState()} <: allMalfs;
  		dcl state :Malfunction`malfunctionState := malfunction.getState();
    	dcl newPair :map Malfunction`malfunctionState to int := {state |-> pair(state) + 1};
    	allMalfs := allMalfs ++ newPair;
    );
    return allMalfs;
   )
  pre currentUser <> nil and currentUser in set employees and currentUser.getRole() = <Admin>;



 -- general functions
 
 pure public static getInstance: () ==> PrintManager
 	getInstance() ==
 		return printManager;
	
 public static clearInstance: () ==> ()
 	clearInstance() ==
	 		printManager := new PrintManager();
	 		
	
	public pure getCurrentUser: () ==> [User]	
		getCurrentUser()==
			return currentUser;
			 	
	public pure getPrinters: () ==> set of Printer
		getPrinters() == 
			return  printers
		pre currentUser <> nil;
		
	public pure getQueues: () ==> set of Queue
		getQueues() == 
			return  queues
		pre currentUser <> nil;
		
	public getMalfunctions: () ==> set of Malfunction
		getMalfunctions() ==
			return malfunctions
		pre currentUser <>nil and currentUser in set employees;
		
	public addMalfunction: Malfunction ==> ()
		addMalfunction(malf) ==
			malfunctions := malfunctions union {malf}
		pre currentUser <> nil;

 	public getEmployees: () ==> set of Employee
 		getEmployees() ==
 			(
 				dcl emp: set of Employee := {};
 				for all employee in set employees do 
 				(
 					if employee.getRole() = <Regular> then
 						emp := emp union {employee}
 				);
 				return emp;
 			)
 			pre currentUser.getRole() <> <Admin>;  
 
  public getEmployee: seq of (char) ==> [Employee]
  	getEmployee(name) ==
  		(
	  		for all employee in set employees do 
	  		(
	  			if employee.getName() = name and employee.getRole() <> <Admin> then 
	  			(
	  				return employee
	  			)
	  		);
	  		return nil
  		)
  	pre currentUser <> nil and currentUser in set employees and currentUser.getRole() = <Admin>;


end PrintManager
